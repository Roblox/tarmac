//! Defines how Tarmac generates Lua code for linking to assets.
//!
//! Tarmac uses structs with `Display` impls to build up templates.

use std::{collections::HashMap, fmt};

use crate::{
    asset_name::AssetName,
    data::ImageSlice,
    lua_ast::{Block, Expression, Statement, Table},
};

const CODEGEN_HEADER: &str =
    "-- This file was @generated by Tarmac. It is not intended for manual editing.";

pub(crate) struct TestBatchTemplate {
    pub inputs: Vec<AssetName>,
}

impl fmt::Display for TestBatchTemplate {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        enum Item<'a> {
            Folder(HashMap<&'a str, Item<'a>>),
            Input(&'a AssetName),
        }

        let mut indexed_items: HashMap<&str, Item<'_>> = HashMap::new();

        for input in &self.inputs {
            let mut components = input.components().peekable();
            let mut current_dir = &mut indexed_items;

            loop {
                let name = components.next().unwrap();
                let has_more_components = components.peek().is_some();

                if has_more_components {
                    let next_entry = current_dir
                        .entry(name)
                        .or_insert_with(|| Item::Folder(HashMap::new()));

                    match next_entry {
                        Item::Folder(next_dir) => {
                            current_dir = next_dir;
                        }
                        Item::Input(_) => {
                            panic!("Malformed input tree");
                        }
                    }
                } else {
                    current_dir.insert(name, Item::Input(input));
                    break;
                }
            }
        }

        writeln!(formatter, "{}", CODEGEN_HEADER)?;

        fn build_item(item: &Item<'_>) -> Expression {
            match item {
                Item::Folder(children) => {
                    let entries = children
                        .iter()
                        .map(|(&name, child)| (name.into(), build_item(child)))
                        .collect();

                    Expression::table(entries)
                }
                Item::Input(asset_name) => Expression::String(asset_name.to_string()),
            }
        }

        let ast = Block {
            statements: vec![Statement::Return(build_item(&Item::Folder(indexed_items)))],
        };

        write!(formatter, "{}", ast)?;

        Ok(())
    }
}

/// Codegen template for CodegenKind::AssetUrl
pub(crate) struct AssetUrlTemplate {
    pub id: u64,
}

impl AssetUrlTemplate {
    fn to_lua(&self) -> Expression {
        Expression::String(format!("rbxassetid://{}", self.id))
    }
}

impl fmt::Display for AssetUrlTemplate {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        writeln!(formatter, "{}", CODEGEN_HEADER)?;
        writeln!(formatter, "return \"rbxassetid://{}\"", self.id)?;

        Ok(())
    }
}

pub(crate) struct UrlAndSliceTemplate {
    pub id: u64,
    pub slice: Option<ImageSlice>,
}

impl UrlAndSliceTemplate {
    fn to_lua(&self) -> Expression {
        let mut table = Table::new();

        table.add_entry("Image", format!("rbxassetid://{}", self.id));

        if let Some(slice) = self.slice {
            let offset = slice.min();
            let size = slice.size();

            table.add_entry(
                "ImageRectOffset",
                Expression::Raw(format!("Vector2.new({}, {})", offset.0, offset.1)),
            );

            table.add_entry(
                "ImageRectSize",
                Expression::Raw(format!("Vector2.new({}, {})", size.0, size.1)),
            );
        }

        Expression::Table(table)
    }
}

impl fmt::Display for UrlAndSliceTemplate {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        writeln!(formatter, "{}", CODEGEN_HEADER)?;

        let ast = Block {
            statements: vec![Statement::Return(self.to_lua())],
        };

        write!(formatter, "{}", ast)?;

        Ok(())
    }
}
